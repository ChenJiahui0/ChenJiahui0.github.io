---
title: 基本数据结构篇三之堆
layout: post
author: 陈家辉
tags:
- 数据结构
- 算法
- 基础
- 古城算法
---

# 参考

[古城算法ppt](https://docs.google.com/presentation/d/1au50lTOsmbxkfg9tVUFNqx73ZF335al4L1Vj2abR8EA/edit#slide=id.p)
[oi-wiki](https://oi-wiki.org/ds/heap/)

# 是什么

堆是一棵树，每个节点都有一个键值，每个节点的键值都大于/小于子节点键值。

* 小顶堆：父节点键值小于子节点
* 大顶堆：父节点键值大于子节点

## 特性

<img src="https://cdn.jsdelivr.net/gh/CJH876492153/picture@main/SecDTtS3jQ-R0jj3cMMnFhUzo6qJWTJu4TbGsFqOVfzbgxOsvob7VtyAWbOlxKgQ2u0aY_fxGv-vIQ2tYB1WODiy5z2IpJCkgn5j9Uz5fSX7xITvHnCHYrn1NlVndxqxF95AkXJXM-l5QPRCjsEHqVnN=s2048.png" alt="img" style="zoom:50%;" />
$$
index(child) = 2k+1 = 2k+2\\
index(parent) = (k-1)/2\\
comment:第k个节点的子节点坐标为 2k+1或2k+2，父节点坐标为(k-1)/2
$$


## Heapify

$$
input = array \\
output = min\_heap|max\_heap
$$

根据输入的数组以及优先级顺序，生成对应的大顶堆或小顶堆。

### 习题

[堆化](https://www.lintcode.com/problem/130/)

<img src="https://cdn.jsdelivr.net/gh/CJH876492153/picture@main/image-20230704181006345.png" alt="image-20230704181006345" style="zoom: 50%;" />

```java
public class Heap {
    public static void main(String[] args) {
        int[] a = new int[]{5, 3, 1, 2, 4};
        for (int i = a.length / 2; i >= 0; i--) {
            heapify2(a, i);
        }
        System.out.println(Arrays.toString(a));
    }

    public static void heapify(int[] array, int i) {
        int largest = i, l = 2 * i + 1, r = 2 * i + 2;
        if (l < array.length && array[largest] < array[l]) largest = l;
        if (r < array.length && array[largest] < array[r]) largest = r;
        if (largest != i) {
            int swap = array[largest];
            array[largest] = array[i];
            array[i] = swap;
            heapify(array, largest);
        }
    }

    public static void heapify2(int[] array, int i) {
        while (true) {
            int largest = i, l = 2 * i + 1, r = 2 * i + 2;
            if (l < array.length && array[largest] < array[l]) largest = l;
            if (r < array.length && array[largest] < array[r]) largest = r;
            if (largest == i) {
                break;
            }
            int swap = array[largest];
            array[largest] = array[i];
            array[i] = swap;
            i = largest;
        }
    }
}
```


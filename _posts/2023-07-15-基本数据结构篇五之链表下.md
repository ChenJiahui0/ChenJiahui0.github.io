---
title: 基本数据结构篇五之链表下
subtitle: 删除|复制|结构转换
layout: post
author: 陈家辉
tags:
- 数据结构
- 算法
- 基础
- 古城算法

---

# 参考

[古城算法ppt](https://docs.google.com/presentation/d/14r1RwxJi-ko1m2cRC8F3U2QnXeI6ykKfjqYHfefOK-E/edit#slide=id.gd24f3d6860_0_0)

[oi-wiki](https://oi-wiki.org/ds/linked-list/)

## 习题

### [移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/description/)

<img src="https://cdn.jsdelivr.net/gh/Chenjiahui0/picture@main/202307151621864.png" alt="image-20230715161044760" style="zoom:67%;" />

```java
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        ListNode hair = new ListNode(0);
        hair.next = head;
        ListNode cur = hair;
        while(cur.next!=null){
            if(cur.next.val == val) cur.next = cur.next.next;
            else cur = cur.next;
        }
        return hair.next;
    }
}
```

递归写法

```java
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        if(head == null) return null;
        head.next = removeElements(head.next,val);
        return head.val == val ? head.next : head;
    }
}
```

### [删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/)

<img src="https://cdn.jsdelivr.net/gh/Chenjiahui0/picture@main/202307151930080.png" alt="image-20230715193015010" style="zoom:67%;" />

```java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode cur = head;
        while(cur!=null && cur.next != null){
            if(cur.val == cur.next.val) cur.next = cur.next.next;
            else cur = cur.next;
        }
        return head;
    }
}
```

递归

```java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if(head==null || head.next==null) return head;
        head.next = deleteDuplicates(head.next);
        return head.val == head.next.val ? head.next : head;
    }
}
```

### [删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/description/)

![image-20230715200817272](https://cdn.jsdelivr.net/gh/Chenjiahui0/picture@main/202307152008321.png)

```java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode hair = new ListNode(-101,head);
        ListNode pre = hair;
        ListNode cur = head;
        while(cur!=null && cur.next!=null){
            if(cur.val == cur.next.val){
                ListNode tmp = cur.next;
                while(tmp!=null && tmp.val==cur.val){
                    tmp = tmp.next;
                }
                pre.next = tmp;
                cur = tmp;
            }else{
                pre = pre.next;
                cur = cur.next;
            }
        }
        return hair.next;
    }
}
```

### [删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/)

![image-20230715201817800](https://cdn.jsdelivr.net/gh/Chenjiahui0/picture@main/202307152018846.png)

利用双指针，一次遍历即可完成

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0,head);
        ListNode first,second;
        first = second = dummy;
        for(int i=0;i<=n;i++){
            first = first.next;
        }
        while(first!=null){
            first = first.next;
            second = second.next;
        }
        second.next = second.next.next;
        return dummy.next;
    }
}
```

### [从链表中删去总和值为零的连续节点](https://leetcode.cn/problems/remove-zero-sum-consecutive-nodes-from-linked-list/description/)

![image-20230716140721098](https://cdn.jsdelivr.net/gh/Chenjiahui0/picture@main/202307161407170.png)

2pass + 前缀和

```java
class Solution {
    public ListNode removeZeroSumSublists(ListNode head) {
        ListNode hair = new ListNode(0,head);
        Map<Integer,ListNode> map = new HashMap<>();
        ListNode tmp = hair;
        int prefixSum = 0;
        while(tmp != null){
            prefixSum += tmp.val;
            map.put(prefixSum,tmp);
            tmp = tmp.next;
        }
        prefixSum = 0;
        tmp = hair;
        while(tmp != null){
            prefixSum += tmp.val;
            tmp.next = map.get(prefixSum).next;
            tmp = tmp.next;
        }

        return hair.next;
    }
}
```


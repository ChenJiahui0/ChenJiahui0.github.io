---
title: 基本数据结构篇四之栈与队列
layout: post
author: 陈家辉
tags:
- 数据结构
- 算法
- 基础
- 古城算法
---

# 参考

[古城算法ppt](https://docs.google.com/presentation/d/1SmPo1VpUMs_gbkaugEYZoIhK4XCjR-afTaGpjv_J7z8/edit#slide=id.p)

[oi-wiki](https://oi-wiki.org/ds/stack/)

# 是什么
![img](https://oi-wiki.org/ds/images/stack.svg)

栈是 OI 中常用的一种线性数据结构，栈的修改是按照后进先出的原则进行的，因此栈通常被称为是后进先出（last in first out）表，简称 LIFO 表。

![队列](https://oi-wiki.org/ds/images/queue.svg)

队列（queue）是一种具有「先进入队列的元素一定先出队列」性质的表。由于该性质，队列通常也被称为先进先出（first in first out）表，简称 FIFO 表。

## 习题

### [最小栈](https://leetcode.cn/problems/min-stack/)

<img src="https://cdn.jsdelivr.net/gh/Chenjiahui0/picture@main/202307052132981.png" alt="image-20230705213203882" style="zoom:67%;" />

> 思路：使用两个栈存储数据，一个正常的栈，第二个只存小于等于栈顶元素的栈。

```java
class MinStack {
    Stack<Integer> stack = new Stack<>();
    Stack<Integer> minStack = new Stack<>();

    public MinStack() {

    }
    
    public void push(int val) {
        stack.push(val);
        if(minStack.isEmpty() || minStack.peek() >= val){
            minStack.push(val);
        }
    }
    
    public void pop() {
        int v = stack.pop();
        if(minStack.peek() == v){
            minStack.pop();
        }
    }
    
    public int top() {
        return stack.peek();
    }
    
    public int getMin() {
        return minStack.peek();
    }
}
```

稍稍优化一下

```java
class MinStack {
    Stack<Integer> stack = new Stack<>();
    Stack<int[]> minStack = new Stack<>();

    public MinStack() {

    }
    
    public void push(int val) {
        stack.push(val);
        if(minStack.isEmpty() || minStack.peek()[0] > val){
            minStack.push(new int[]{val,1});
        }else if(minStack.peek()[0] == val){
            minStack.peek()[1] += 1;
        }
    }
    
    public void pop() {
        int v = stack.pop();
        int[] peek = minStack.peek();
        if(peek[0] == v){
            if(peek[1]==1){
                minStack.pop();
            }else{
                peek[1] -= 1;
            }
        }
    }
    
    public int top() {
        return stack.peek();
    }
    
    public int getMin() {
        return minStack.peek()[0];
    }
}
```

### [用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)

<img src="https://cdn.jsdelivr.net/gh/Chenjiahui0/picture@main/202307052153893.png" alt="image-20230705215342848" style="zoom:67%;" />

```java
class MyQueue {
    Stack<Integer> pushStack = new Stack<>();
    Stack<Integer> popStack = new Stack<>();
    public MyQueue() {

    }
    
    public void push(int x) {
        pushStack.push(x);
    }
    
    public int pop() {
        if(popStack.isEmpty()){
            while(!pushStack.isEmpty()){
                popStack.push(pushStack.pop());
            }
        }
        return popStack.pop();
    }
    
    public int peek() {
        if(popStack.isEmpty()){
            while(!pushStack.isEmpty()){
                popStack.push(pushStack.pop());
            }
        }
        return popStack.peek();
    }
    
    public boolean empty() {
        return pushStack.isEmpty() && popStack.isEmpty();
    }
}
```

### [用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)

<img src="https://cdn.jsdelivr.net/gh/Chenjiahui0/picture@main/202307052207237.png" alt="image-20230705220716194" style="zoom:67%;" />

> 以下两种写法都行，但是考点在于场景，是 read heavy 还是 write heavy，需要根据这两种情况，选择对应的写法。

pop  O(n)

```java
class MyStack {
    Queue<Integer> q1 = new LinkedList<>();
    Queue<Integer> q2 = new LinkedList<>();
    int top;
    public MyStack() {

    }
    
    public void push(int x) {
        q1.offer(x);
        top = x;
    }
    
    public int pop() {
        while(q1.size()>1){
            top = q1.poll();
            q2.offer(top);
        } 
        int res = q1.poll();
        Queue<Integer> tmp = q1;
        q1 = q2;
        q2 = tmp;
        return res;
    }
    
    public int top() {
        return top;
    }
    
    public boolean empty() {
        return q1.isEmpty() && q2.isEmpty();
    }
}
```

push O(n)

```java
class MyStack {
    Queue<Integer> q1 = new LinkedList<>();
    Queue<Integer> q2 = new LinkedList<>();
    public MyStack() {

    }
    
    public void push(int x) {
        q1.offer(x);
        while(!q2.isEmpty()) q1.offer(q2.poll());
        while(!q1.isEmpty()) q2.offer(q1.poll());
    }
    
    public int pop() {
        return q2.poll();
    }
    
    public int top() {
        return q2.peek();
    }
    
    public boolean empty() {
        return q1.isEmpty() && q2.isEmpty();
    }
}
```

### [设计循环队列](https://leetcode.cn/problems/design-circular-queue/)

<img src="https://cdn.jsdelivr.net/gh/Chenjiahui0/picture@main/202307052239301.png" alt="image-20230705223924255" style="zoom:67%;" />

```java
class MyCircularQueue {
    int front, rear, size;
    int size;
    int[] q;
    public MyCircularQueue(int k) {
        q = new int[k];
        rear = -1;
    }
    
    public boolean enQueue(int value) {
        if(isFull()){
            return false;
        }else{
            rear = (rear+1)%q.length;
            q[rear] = value;
            size++;
            return true;
        }
    }
    
    public boolean deQueue() {
        if(isEmpty()){
            return false;
        }else{
            front = (front+1)%q.length;
            size--;
            return true;
        }
    }
    
    public int Front() {
        if(isEmpty()){
            return -1;
        }else{
            return q[front%q.length];
        }
    }
    
    public int Rear() {
        if(isEmpty()){
            return -1;
        }else{
            return q[rear%q.length];
        }
    }
    
    public boolean isEmpty() {
        return size==0;
    }
    
    public boolean isFull() {
        return size == q.length;
    }
}
```


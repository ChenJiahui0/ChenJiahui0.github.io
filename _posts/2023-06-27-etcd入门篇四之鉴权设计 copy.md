---
title: etcd源码篇之v3鉴权设计
layout: post
header-img: "https://w.wallhaven.cc/full/ex/wallhaven-ex9gwo.png"
description: etcd系列第四篇博客
author: 陈家辉
tags:
- etcd
---

> 该篇基于etcd v3的视角

# 概述

## 功能需求

* 每个链接都需要鉴权，而非每个请求
  * 基于gRPC API实现用户密码鉴权
  * 在鉴权策略改变后，必须刷新鉴权
* 需要跟v2一样有用且简单
  * v3 采取的是flat key space而不是文件夹结构。权限检测将采取内部匹配的方式。
* 相较于v2需要更强的一致性保证

## 主要改动

* 客户端必须在发送经过身份验证的请求之前创建专用连接

* 向 Raft 命令(`etcdserverpb.InternalRaftRequest`)添加权限信息(用户 ID 和授权版本)

* 每个请求都在状态机层(而不是 API 层)中检查权限

## 权限元数据一致性

鉴权元数据需要被存储并且使用etcd的raft协议进行管理。需要保证不影响集群的可用性和一致性。如果读写元数据需要全体成员的同意，那么一旦有一个节点出现故障，就会直接影响整个集群的可用性。所以基于Raft的共识就足够了，不需要让所有节点同意。

Etcd v2协议中的身份验证机制有一个棘手的部分：每个权限检查都由接收客户端请求的 etcd 成员(server/etcdserver/api/v2http/client.go)处理，包括跟随者成员。因此，检查可能基于过时的元数据。

这种过时性意味着，一旦运算符执行 `etcdctl`，就无法反映身份验证配置。因此，无法知道陈旧的元数据活动了多长时间。实际上，配置更改会在命令执行后立即反映出来。但是，在某些重负载的情况下，不一致的状态可能会延长，并且可能会导致用户和开发人员出现不直观的情况。它需要一个像这样的变通方法: https://github.com/etcd-io/etcd/pull/4317#issuecomment-179037582

### 不一致鉴权对于线性请求不安全

不一致的身份验证状态对写操作最为严重。即使操作符禁用对用户的写操作，如果写操作只是针对密钥值存储而不是身份验证系统进行排序，那么写操作也有可能成功完成。如果不对认证存储和键值存储进行排序，系统将很容易受到过时的权限攻击。

因此，应该将权限检查逻辑添加到 etcd 的状态机中。每个状态机应该根据其在应用阶段中的权限信息检查请求(因此身份验证信息不能过时)。

# 设计和实现

## 鉴权

首先，客户端必须创建一个个RPC链接用来认证它的用户id和密码。如果鉴权通过，服务端将会返回一个token，客户端请求携带该token即可完成授权。

客户端获取token后，由于gRPC不支持已有链接携带token，需要新建链接进行后续的通信。

### `Authenticate()` RPC实现细节

`Authenticate()` RPC基于用户名和密码生成token。etcd保存并且使用`bcrypt`进行检测。`bcrypt`密码检测机制需要昂贵的计算资源，在传统x86服务器上需要将近100ms。因此，在状态机应用阶段执行检查将会导致性能问题：整个etcd集群一秒只能执行10次Authenticate()。

为了性能，v3鉴权机制在etcd的API层检查密码，在API层可以和raft并行。然而，这可能导致潜在的检查时间/使用时间(TOCTOU)权限失效:

1. 客户端A发送`Authenticate()` 请求
2. API层处理密码检查部分
3. 客户端B发送`ChangePassword()`请求，服务端完成
4. 状态机层从A获取到`Authenticate()`的版本号
5. 服务返回给A success
6. 现在A使用了一个过时的密码验证成功

为了避免这种情况，API 层根据授权存储的修订号执行版本号验证。在密码检查期间，API 层保存授权存储的修订号。成功的密码检查之后，API 层将比较保存的修订号和最新的修订号。如果数字不同，则意味着其他人更新了身份验证元数据。所以它会重新检查。通过这种机制，可以避免过时密码的通过检验。

### 在API层解析token

在使用 `Authenticate ()`进行身份验证之后，客户端需要创建一个 gRPC 连接，除了现有的初始化过程之外，客户端还必须将令牌与新创建的链接关联。`Grpc.WithPerRPCCreentials ()`为此提供了功能。

客户端每次请求都带着token，服务端可以使用`grpc.metadata.FromIncomingContext()`获取token。服务端可以获取发出请求的用户以及授权用户的时间。信息将由 API 层填充到raft log entry的(`etcdserverpb.InternalRaftRequest`)请求头（`etcdserverpb.RequestHeader.Username` 和 `etcdserverpb.RequestHeader.AuthRevision`）

`etcdserverpb.RequestHeader` 中的授权信息在状态机的应用阶段检查 。此步骤检查用户是否被授予对授权存储区的最新修订版本的请求密钥的权限。

# 关于 KVS 模型与文件系统模型之间差异的注释

Etcd v3是一个 KVS，而不是一个文件系统。因此，可以以确切的密钥名或密钥范围(如[“开始密钥”、“结束密钥”])的形式将权限授予用户。这意味着授予不存在的密钥的权限是可能的。用户应该关心非预期的权限授予。对于类似于 system 的文件系统(例如 Chubby 或 ZooKeeper) ，类似 inode 的数据结构可以包含权限信息。因此，不可能授予不存在的键的权限(粘贴位的情况除外)。

Etcd v3模型需要对元数据进行多次查找，这与文件系统(如系统)不同。最坏情况下的查找成本将是用户授予的keys和intervals的总和。由于 v3的flat key space与 Unix 的文件系统模型完全不同(每个 inode 都包含权限元数据) ，因此成本是无法避免的。实际上，并不会很慢，因为元数据足够小，可以从缓存中获得。
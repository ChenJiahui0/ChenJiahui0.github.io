---
title: etcd入门篇四之v3鉴权设计
layout: post
header-img: "https://w.wallhaven.cc/full/ex/wallhaven-ex9gwo.png"
description: etcd系列第四篇博客
author: 陈家辉
tags:
- etcd
---

> 该篇基于etcd v3的视角

# 概述

## 功能需求

* 每个链接都需要鉴权，而非每个请求
  * 基于gRPC API实现用户密码鉴权
  * 在鉴权策略改变后，必须刷新鉴权
* 需要跟v2一样有用且简单
  * v3 采取的是flat key space而不是文件夹结构。权限检测将采取内部匹配的方式。
* 相较于v2需要更强的一致性保证

## 主要改动

* 客户端必须在发送经过身份验证的请求之前创建专用连接

* 向 Raft 命令(`etcdserverpb.InternalRaftRequest`)添加权限信息(用户 ID 和授权版本)

* 每个请求都在状态机层(而不是 API 层)中检查权限

## 权限元数据一致性

鉴权元数据需要被存储并且使用etcd的raft协议进行管理。需要保证不影响集群的可用性和一致性。如果读写元数据需要全体成员的同意，那么一旦有一个节点出现故障，就会直接影响整个集群的可用性。所以基于Raft的共识就足够了，不需要让所有节点同意。

Etcd v2协议中的身份验证机制有一个棘手的部分：每个权限检查都由接收客户端请求的 etcd 成员(server/etcdserver/api/v2http/client.go)处理，包括跟随者成员。因此，检查可能基于过时的元数据。

这种过时性意味着，一旦运算符执行 `etcdctl`，就无法反映身份验证配置。因此，无法知道陈旧的元数据活动了多长时间。实际上，配置更改会在命令执行后立即反映出来。但是，在某些重负载的情况下，不一致的状态可能会延长，并且可能会导致用户和开发人员出现不直观的情况。它需要一个像这样的变通方法: https://github.com/etcd-io/etcd/pull/4317#issuecomment-179037582

### 不一致鉴权对于线性请求不安全

不一致的身份验证状态对写操作最为严重。即使操作符禁用对用户的写操作，如果写操作只是针对密钥值存储而不是身份验证系统进行排序，那么写操作也有可能成功完成。如果不对认证存储和键值存储进行排序，系统将很容易受到过时的权限攻击。

因此，应该将权限检查逻辑添加到 etcd 的状态机中。每个状态机应该根据其在应用阶段中的权限信息检查请求(因此身份验证信息不能过时)。

# 设计和实现

## 鉴权

